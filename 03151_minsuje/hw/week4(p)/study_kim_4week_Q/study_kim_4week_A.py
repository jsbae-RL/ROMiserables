def solution(N):
    pow = 1
    while pow * 2 <= N:
        pow *= 2
    if pow == N:
        return pow
    return (N - pow) * 2 #N%pow = (N-pow) *2 마지막 숫자자
# N = int(input())
# print(solution(N))
print(solution(2))
print(solution(4))
print(solution(6))
print(solution(8))
print(solution(10))
print(solution(12))
print(solution(14))
print(solution(500000))
#스텍으로 처리해도 되겠다 싶었지만 2의 배수가 너무 눈에뜀
#아래에 서술 하겠음

#1~n까지 과정을 하다보면 홀수가 다 제거됨
#단 n이 홀수 이면 n,2,4,6,8,10....이런식으로감

# 2,4,6,8,10,12,14,16을 일일이 구하기도 했음 규칙 찾으려고
#위에 짝수를 한건 홀수랑 짝수랑 애매 해서 일딴 짝수 아무거나 한거거

#일딴 2**x이랑 마지막 남는게 관련 있겠다 싶음 (2**x는 편의상 쓴거고 n보다 작은 2의 x승)
#그래서 냅따 2**x이 나오는거 아닌가 답 넣었으나 오답
#-> 이건 2,4,4,8 이렇게 나와서 했던건데 더해보니 4,8,12,16 이런식으로 나와서 아니구나 했음
 

#여기서 냅다 n-2**x를 해보았음 딱 정답의 절반이었음 물론 2 4 8 16 같은 애들은 적용 안되니 따로 if문으로 빼야겠네? 싶었음

#이제 홀수도 확인해봐야 했음 위에 짝수에서 나온 결과를 한번 같이 해봄 (n-2**x)*2 직접 세서 했음 그러니 맞는걸 확인하고
#바로 위에 식을 세움

#스텍으로 처리하면 쉬우나 단점이 스택은 결국 위에 식에 비해 과정을 많이해야함.
# 수가 작으면 스텍이 조금더 유리 할 수 있겠으나 수가 커지면 커질수록 스텍은 모든 과정을 반복해야 겠지만
# 위의 식은 수가 커질수록 유리함 과정을 생략해버리니까 스텍으로 작성도 했지만 둘중엔 위에가 더 좋은 식이다 생각해서 이거만 남겨둠
# -끝-

# ps.수학좋아하는데 읽어보면서 수학 냄새가 나서 너무 좋았습니다 오랫만에 재밌는 문제를 푼거 같아요. 감사합니다.